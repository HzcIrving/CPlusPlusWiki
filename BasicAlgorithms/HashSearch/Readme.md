## 哈希优化搜索策略

在算法题中，我们常通过将线性查找替换为哈希查找来降低算法的时间复杂度。HashSearch算法通过将数据存储在哈希表中，从而实现O(1)的查找效率。 

### 题目 

```
给定一个整数数组 nums 和一个目标元素 target ，请在数组中搜索“和”为 target 的两个元素，并返回它们的数组索引。返回任意一个解即可。
``` 

#### Method01 暴力搜索 

时间复杂度 $O(n^2)$， 空间复杂度 $O(1)$。

#### Hash 
思路，主要是查看target-nums[i]是否在哈希表中，如果在，则返回，否则将nums[i]加入哈希表。  


##### map vs. unorderd map 
std::map 和 std::unordered_map 是 C++ 标准库中的两种关联容器，它们用于存储键值对。它们之间的主要区别如下：

1. 内部实现:

    std::map 是基于红黑树实现的，它是一种自平衡二叉搜索树。
    std::unordered_map 是基于哈希表实现的。
    
2. 有序性:

    std::map 中的元素是按照键的顺序排序的。因此，当你遍历 std::map 时，你会得到一个有序的键值对序列。
    std::unordered_map 中的元素是无序的。元素的存储顺序取决于哈希函数和碰撞解决策略。
    
3. 性能:

    std::map 的插入、删除和查找操作的平均时间复杂度为 O(log n)，因为红黑树的插入和删除操作需要保持树的平衡。
    std::unordered_map 的插入、删除和查找操作的平均时间复杂度为 O(1)，但在最坏情况下（例如哈希碰撞较多时），时间复杂度可能达到 O(n)。
    
4. 内存使用:

    std::map 通常比 std::unordered_map 使用更多的内存，因为红黑树节点需要存储额外的平衡信息。
    std::unordered_map 的内存使用相对较低，因为它只需要存储键值对和哈希表信息。
    
5. 哈希函数:

    std::unordered_map 需要一个哈希函数来计算键的哈希值。默认情况下，它使用 std::hash，但你可以提供自定义的哈希函数。
    std::map 不需要哈希函数，因为它使用键的比较函数（默认为 std::less）来维护元素的顺序。 

总结: 
| 特性               | std::map                        | std::unordered_map              |
|-------------------|---------------------------------|---------------------------------|
| 内部实现           | 基于红黑树                      | 基于哈希表                      |
| 有序性             | 有序（按键排序）                | 无序                            |
| 插入、删除、查找时间复杂度 | O(log n)                        | 平均 O(1)，最坏 O(n)            |
| 内存使用           | 较高（存储平衡信息）            | 较低（仅存储键值对和哈希表信息）|
| 哈希函数           | 不需要                          | 需要（默认为 std::hash）        |

