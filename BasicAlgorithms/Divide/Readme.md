## 分治算法 

一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。

1. 问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。
2. 子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决。
3. 子问题的解可以合并：原问题的解通过合并子问题的解得来。 

分治不仅可以有效地解决算法问题，往往还可以**提升算法效率**。

在排序算法中，**快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略**。 


### 为什么分治高效？ 

以分治排序为例说明：

- 冒泡处理长度为$n$的数组，需要$O(n^2)$ 
- 分治1次+冒泡:$O(n^2/2+2n)$ 
- 当$n>4$时，分治带来显著的性能提升。 

- 若分治n次（不停划分终点），直到子数组只剩1个元素，**分治排序！** 
- 时间复杂度$O(n\log n)$ 
    - 考虑二分问题，考虑这样一个事实：每次迭代，搜索的范围都会减半。这意味着，算法的迭代次数与“将 $n$ 减少到 1 需要除以多少个 2”是相等的。 
    - $n$ 初始大小， $k$是迭代次数 
      - $n$ -> $n/2$ -> $n/4$ -> $n/8$ -> ... -> $n/2^k$ 
    - 最坏的情况: $n/2^k = 1$ , $k=\log n$ 
    - 由于分治除了分还需要治，即归并；将小数组归并成较大的数组。在归并过程中，每个元素都会被比较和移动一次，因此归并步骤的时间复杂度是 $O(n)$ 
    - 由于分解和归并步骤是连续进行的，所以总的时间复杂度是这两个步骤的乘积 $O(n\log n)$ 


- 多设置划分点， **桶排序**，适合海量数据，理论上时间复杂度 $O(n+k)$  

### 并行计算优化¶ 

我们知道，分治生成的子问题是相互独立的，因此**通常可以并行解决**。也就是说，分治不仅可以降低算法的时间复杂度，还有利于**操作系统的并行优化**。

并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间。

比如在“桶排序”中，我们将**海量的数据平均分配到各个桶中**，则可将所有桶的排**序任务分散到各个计算单元**，完成后再合并结果。 

### 分治应用场景 

一方面，分治可以用来解决许多经典算法问题。

1. **寻找最近点对**：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对。
2. **大整数乘法**：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法。
3. **矩阵乘法**：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法。
4. **汉诺塔问题**：汉诺塔问题可以通过递归解决，这是典型的分治策略应用。
5. **求解逆序对**：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解。

另一方面，分治在算法和数据结构的设计中应用得非常广泛。

1. **二分查找**：二分查找是将有序数组从中点索引处分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，并在剩余区间执行相同的二分操作。
2. **归并排序**：本节开头已介绍，不再赘述。
3. **快速排序**：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。
4. **桶排序**：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。
5. **树**：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用。
6. **堆**：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。
7. **哈希****表**：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。