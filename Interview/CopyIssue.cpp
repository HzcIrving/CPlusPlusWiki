/*
深浅拷贝，面试常见问题：
- 浅拷贝 --- 简单的赋值拷贝操作 
- 深拷贝 --- 在堆区new重新申请空间，进行拷贝操作 

将一个对象完全复制到另一个对象中，包括所有成员变量和动态分配的内存。
而浅拷贝只是简单地复制指针，这样两个对象会共享同一块内存，可能会导致不可预知的错误。 

1.深拷贝的定义
深拷贝是将一个对象完全复制到另一个对象中，包括所有成员变量和动态分配的内存。这意味着如果源对象中有指向堆内存的指针，那么深拷贝会为目标对象分配一块新的内存，将源对象指针所指向的数据复制到这块新内存中。因此，深拷贝可以保证两个对象之间的数据完全独立，任何一个对象的修改都不会影响另一个对象。 

-- 实现:  
深拷贝通常需要在类的复制构造函数和赋值运算符重载函数中进行实现。在复制构造函数中，需要为目标对象分配新的内存，并将源对象中的数据复制到新的内存中。
在赋值运算符重载函数中，需要先释放目标对象已有的内存，再为目标对象分配新的内存，并将源对象中的数据复制到新的内存中。 

2. 浅拷贝的定义与实现 
-- 浅拷贝的定义
浅拷贝是将一个对象的指针成员变量复制到另一个对象中，这样两个对象会共享同一块内存。这意味着如果其中一个对象修改了这块内存中的数据，另一个对象也会受到影响。因此，浅拷贝可能会导致不可预知的错误。

-- 浅拷贝的实现
浅拷贝通常是通过默认的复制构造函数和赋值运算符重载函数实现的。默认的复制构造函数和赋值运算符重载函数只是简单地将一个对象的指针成员变量复制到另一个对象中，这样两个对象会共享同一块内存。

3. 应用范围
深拷贝通常用于需要复制[动态分配内存]的对象，例如字符串类、容器类等。
在这些类中，如果使用浅拷贝，会导致多个对象共享同一块内存，修改一个对象的数据会影响其他对象。而深拷贝可以保证每个对象拥有[独立的内存]，修改一个对象的数据不会影响其他对象。
浅拷贝通常用于不需要复制动态分配内存的对象，例如基本数据类型、指针等。在这些对象中，使用浅拷贝不会有影响，而且可以[提高代码的性能]。 

深拷贝和浅拷贝是C++编程中常用的两种拷贝方式，各自有不同的应用场景。深拷贝会复制对象的所有成员变量，并且为每个成员变量分配独立的内存；而浅拷贝只是将指针成员变量的地址复制到另一个对象中，导致多个对象共享同一块内存。程序员需要根据具体的需求选择合适的拷贝方式，以保证程序的正确性和性能。

拷贝控制函数包括默认构造函数、复制构造函数、移动构造函数、复制赋值运算符重载函数、移动赋值运算符重载函数和析构函数，程序员可以根据需要自定义这些函数，以满足特定的需求。在自定义拷贝控制函数时，需要注意拷贝的方式和内存的管理，避免内存泄漏和悬垂指针的出现。同时，需要注意在使用智能指针等RAII技术的情况下，不需要自定义拷贝控制函数，因为这些技术已经实现了拷贝控制功能。 

总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题
*/

#include <iostream> 
using namespace std;  
class Person{
public: 
    // 无参构造 
    Person(){
        cout << "无参构造" << endl; 
    } 

    // 有参构造 
    Person(int age, int height){
        cout << "有参构造函数!" << endl;
        m_age = age;
        m_height = new int(height); // 堆区开辟动态内存
    } 

    //拷贝构造函数
    Person(const Person& p) { 
        cout << "拷贝构造" << endl; 
        
        m_age = p.m_age; 
        // 如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题  
        m_height = new int(*p.m_height);  
    }

    //析构 
    ~Person(){
        cout << "析构函数" << endl; 
        if(m_height != NULL){
            delete m_height;
        }
    }

public:
    int m_age; 
    int* m_height; 

}; 

void test01()
{
    Person p1(18, 180);
    Person p2(p1);
    cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;
    cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}